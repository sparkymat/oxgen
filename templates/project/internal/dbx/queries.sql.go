// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: queries.sql

package dbx

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearPersonParents = `-- name: ClearPersonParents :exec
UPDATE people
  SET parent_partnership_id = NULL
  WHERE id = $1::uuid
`

func (q *Queries) ClearPersonParents(ctx context.Context, personID uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearPersonParents, personID)
	return err
}

const countSearchedPeople = `-- name: CountSearchedPeople :one
SELECT COUNT(*) FROM people
  WHERE name ILIKE '%' || $1::text || '%'
`

func (q *Queries) CountSearchedPeople(ctx context.Context, query string) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchedPeople, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPartnership = `-- name: CreatePartnership :one
INSERT INTO partnerships (
  partner1_id, partner2_id, is_active, relation_type, started_at, ended_at
) VALUES (
  $1::uuid, $2::uuid, $3::boolean, $4::relation_type, $5, $6
) RETURNING id, partner1_id, partner2_id, relation_type, is_active, started_at, ended_at, created_at, updated_at
`

type CreatePartnershipParams struct {
	PersonID     uuid.UUID
	PartnerID    uuid.UUID
	IsActive     bool
	RelationType RelationType
	StartedAt    pgtype.Date
	EndedAt      pgtype.Date
}

func (q *Queries) CreatePartnership(ctx context.Context, arg CreatePartnershipParams) (Partnership, error) {
	row := q.db.QueryRow(ctx, createPartnership,
		arg.PersonID,
		arg.PartnerID,
		arg.IsActive,
		arg.RelationType,
		arg.StartedAt,
		arg.EndedAt,
	)
	var i Partnership
	err := row.Scan(
		&i.ID,
		&i.Partner1ID,
		&i.Partner2ID,
		&i.RelationType,
		&i.IsActive,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPerson = `-- name: CreatePerson :one
INSERT INTO people (
  name
) VALUES (
  $1::text
) RETURNING id, name, dob, dod, is_dead, gender, current_location, avatar_file_path, created_at, updated_at, parent_partnership_id
`

func (q *Queries) CreatePerson(ctx context.Context, name string) (Person, error) {
	row := q.db.QueryRow(ctx, createPerson, name)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Dob,
		&i.Dod,
		&i.IsDead,
		&i.Gender,
		&i.CurrentLocation,
		&i.AvatarFilePath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParentPartnershipID,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  name, username, encrypted_password
) VALUES (
  $1::text, $2::text, $3::text
) RETURNING id, name, username, encrypted_password, created_at, updated_at
`

type CreateUserParams struct {
	Name              string
	Username          string
	EncryptedPassword string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Name, arg.Username, arg.EncryptedPassword)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.EncryptedPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePerson = `-- name: DeletePerson :exec
DELETE FROM people
  WHERE id = $1::uuid
`

func (q *Queries) DeletePerson(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerson, id)
	return err
}

const fetchPartnershipsForPerson = `-- name: FetchPartnershipsForPerson :many
SELECT id, partner1_id, partner2_id, relation_type, is_active, started_at, ended_at, created_at, updated_at FROM partnerships
  WHERE partner1_id = $1::uuid OR partner2_id = $1::uuid
  ORDER BY coalesce(started_at, created_at) DESC
`

func (q *Queries) FetchPartnershipsForPerson(ctx context.Context, personID uuid.UUID) ([]Partnership, error) {
	rows, err := q.db.Query(ctx, fetchPartnershipsForPerson, personID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Partnership
	for rows.Next() {
		var i Partnership
		if err := rows.Scan(
			&i.ID,
			&i.Partner1ID,
			&i.Partner2ID,
			&i.RelationType,
			&i.IsActive,
			&i.StartedAt,
			&i.EndedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPeopleByIDs = `-- name: FetchPeopleByIDs :many
SELECT id, name, dob, dod, is_dead, gender, current_location, avatar_file_path, created_at, updated_at, parent_partnership_id FROM people
  WHERE id = ANY($1::uuid[])
  ORDER BY name ASC
`

func (q *Queries) FetchPeopleByIDs(ctx context.Context, peopleIds []uuid.UUID) ([]Person, error) {
	rows, err := q.db.Query(ctx, fetchPeopleByIDs, peopleIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Person
	for rows.Next() {
		var i Person
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Dob,
			&i.Dod,
			&i.IsDead,
			&i.Gender,
			&i.CurrentLocation,
			&i.AvatarFilePath,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParentPartnershipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPeopleByParentPartnershipIDs = `-- name: FetchPeopleByParentPartnershipIDs :many
SELECT id, name, dob, dod, is_dead, gender, current_location, avatar_file_path, created_at, updated_at, parent_partnership_id FROM people
  WHERE parent_partnership_id = ANY($1::uuid[])
`

func (q *Queries) FetchPeopleByParentPartnershipIDs(ctx context.Context, parentPartnershipIds []uuid.UUID) ([]Person, error) {
	rows, err := q.db.Query(ctx, fetchPeopleByParentPartnershipIDs, parentPartnershipIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Person
	for rows.Next() {
		var i Person
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Dob,
			&i.Dod,
			&i.IsDead,
			&i.Gender,
			&i.CurrentLocation,
			&i.AvatarFilePath,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParentPartnershipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPerson = `-- name: FetchPerson :one
SELECT id, name, dob, dod, is_dead, gender, current_location, avatar_file_path, created_at, updated_at, parent_partnership_id FROM people
  WHERE id = $1::uuid LIMIT 1
`

func (q *Queries) FetchPerson(ctx context.Context, id uuid.UUID) (Person, error) {
	row := q.db.QueryRow(ctx, fetchPerson, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Dob,
		&i.Dod,
		&i.IsDead,
		&i.Gender,
		&i.CurrentLocation,
		&i.AvatarFilePath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParentPartnershipID,
	)
	return i, err
}

const fetchUserByUsername = `-- name: FetchUserByUsername :one
SELECT id, name, username, encrypted_password, created_at, updated_at FROM users
WHERE username = $1::text LIMIT 1
`

func (q *Queries) FetchUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, fetchUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.EncryptedPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markPersonDead = `-- name: MarkPersonDead :exec
UPDATE people
  SET is_dead = 't'
  WHERE id = $1::uuid
`

func (q *Queries) MarkPersonDead(ctx context.Context, personID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markPersonDead, personID)
	return err
}

const markPersonNotDead = `-- name: MarkPersonNotDead :exec
UPDATE people
  SET is_dead = 'f'
  WHERE id = $1::uuid
`

func (q *Queries) MarkPersonNotDead(ctx context.Context, personID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markPersonNotDead, personID)
	return err
}

const searchPeople = `-- name: SearchPeople :many
SELECT id, name, dob, dod, is_dead, gender, current_location, avatar_file_path, created_at, updated_at, parent_partnership_id FROM people
  WHERE name ILIKE '%' || $1::text || '%'
  ORDER BY name ASC
  LIMIT $3::int 
  OFFSET $2::int
`

type SearchPeopleParams struct {
	Query      string
	PageOffset int32
	PageLimit  int32
}

func (q *Queries) SearchPeople(ctx context.Context, arg SearchPeopleParams) ([]Person, error) {
	rows, err := q.db.Query(ctx, searchPeople, arg.Query, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Person
	for rows.Next() {
		var i Person
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Dob,
			&i.Dod,
			&i.IsDead,
			&i.Gender,
			&i.CurrentLocation,
			&i.AvatarFilePath,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParentPartnershipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const touchPerson = `-- name: TouchPerson :exec
UPDATE people
  SET id = $1::uuid
  WHERE id = $1::uuid
`

func (q *Queries) TouchPerson(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, touchPerson, id)
	return err
}

const updatePersonAvatar = `-- name: UpdatePersonAvatar :exec
UPDATE people
  SET avatar_file_path = $1::text
  WHERE id = $2::uuid
`

type UpdatePersonAvatarParams struct {
	AvatarFilePath string
	PersonID       uuid.UUID
}

func (q *Queries) UpdatePersonAvatar(ctx context.Context, arg UpdatePersonAvatarParams) error {
	_, err := q.db.Exec(ctx, updatePersonAvatar, arg.AvatarFilePath, arg.PersonID)
	return err
}

const updatePersonDob = `-- name: UpdatePersonDob :exec
UPDATE people
  SET dob = $1::date
  WHERE id = $2::uuid
`

type UpdatePersonDobParams struct {
	Dob      pgtype.Date
	PersonID uuid.UUID
}

func (q *Queries) UpdatePersonDob(ctx context.Context, arg UpdatePersonDobParams) error {
	_, err := q.db.Exec(ctx, updatePersonDob, arg.Dob, arg.PersonID)
	return err
}

const updatePersonDod = `-- name: UpdatePersonDod :exec
UPDATE people
  SET dod = $1::date
  WHERE id = $2::uuid
`

type UpdatePersonDodParams struct {
	Dod      pgtype.Date
	PersonID uuid.UUID
}

func (q *Queries) UpdatePersonDod(ctx context.Context, arg UpdatePersonDodParams) error {
	_, err := q.db.Exec(ctx, updatePersonDod, arg.Dod, arg.PersonID)
	return err
}

const updatePersonName = `-- name: UpdatePersonName :exec
UPDATE people
  SET name = $1::text
  WHERE id = $2::uuid
`

type UpdatePersonNameParams struct {
	Name     string
	PersonID uuid.UUID
}

func (q *Queries) UpdatePersonName(ctx context.Context, arg UpdatePersonNameParams) error {
	_, err := q.db.Exec(ctx, updatePersonName, arg.Name, arg.PersonID)
	return err
}

const updatePersonParents = `-- name: UpdatePersonParents :exec
UPDATE people
  SET parent_partnership_id = $1::uuid
  WHERE id = $2::uuid
`

type UpdatePersonParentsParams struct {
	ParentPartnershipID uuid.UUID
	PersonID            uuid.UUID
}

func (q *Queries) UpdatePersonParents(ctx context.Context, arg UpdatePersonParentsParams) error {
	_, err := q.db.Exec(ctx, updatePersonParents, arg.ParentPartnershipID, arg.PersonID)
	return err
}
